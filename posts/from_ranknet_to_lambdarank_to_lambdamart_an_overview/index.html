<!DOCTYPE html>
<html lang="ja">

<head>
  
  
  <script>(function (w, d, s, l, i) {
      w[l] = w[l] || []; w[l].push({
        'gtm.start':
          new Date().getTime(), event: 'gtm.js'
      }); var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
          'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-W5TDG76');
  </script>
  
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=300,initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css"
    integrity="sha512-NmLkDIU1C/C88wi324HBc+S2kLhi08PN5GDeUVVVC/BVt/9Izdsc9SVeVfA1UZbY3sHUlDSyRXhCzHfr6hmPPw=="
    crossorigin="anonymous" />
  
  <link rel="stylesheet" href="https://ryotaro.dev/scss/base.min.d5f9c6d3a478082690f838fa06a179ccee4dea5bd3f0cb3f4a357e2803c48d33.css">
  
  <link rel="stylesheet" href="https://ryotaro.dev/scss/base.ja.min.66816a64bc4ce50ec1c4b76199ca9d69163fc8a69f7abc6ea758d1968d8618b0.css">
  

<link rel="stylesheet" href="https://ryotaro.dev/scss/single.min.8ed5cbfb3dc516e9c4459a65252e4e6e8e9026aabfa9eb9f602cf53b30754966.css">

<link rel="stylesheet" href="https://ryotaro.dev/scss/posts/single.min.0008713f3f7556e78c13cb8efde9cf534239cb206c10ba85ce5a76e6ae9ce758.css">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://kit.fontawesome.com/e48a1b5aa5.js" crossorigin="anonymous"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css"
  integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi"
  crossorigin="anonymous"
>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js"
  integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ"
  crossorigin="anonymous">
</script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body);">
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},  
        {left: '$$', right: '$$', display: true},    
        {left: '\\(', right: '\\)', display: false},  
        {left: '$', right: '$', display: false}  
      ],
      throwOnError : false
    });
  });
</script>
  <title>From RankNet to LambdaRank to LambdaMART: An Overview (2010)</title>
</head>

<body>
  
  
  <noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W5TDG76" height="0" width="0"
      style="display:none;visibility:hidden" />
  </noscript>
  
  
  <header class="navigation">
    <h2><a href="https://ryotaro.dev/">Blanket</a></h2>
    <nav>
      <ul>
        <li><a href="https://ryotaro.dev/about">About</a></li>
        <li><a href="https://ryotaro.dev/posts">Posts</a></li>
        <li><a href="https://ryotaro.dev/tags">Tags</a></li>
        
      </ul>
      <ul>
        
        <li>
          <a href="https://github.com/ryotaro612">
            <i class="fab fa-github"></i>
          </a>
        </li>
        
        
        <li>
          <a href="https://www.linkedin.com/in/ryotaro612/">
            <i class="fab fa-linkedin-in"></i>
          </a>
        </li>
        
        
        <li>
          <a href="https://speakerdeck.com/ryotaro612/">
            <i class="fa-brands fa-speaker-deck"></i>
          </a>
        </li>
        
        <li>
          <a href="https://ryotaro.dev/%20index.xml">
            <i class="fas fa-rss"></i>
          </a>
        </li>
        
      </ul>
    </nav>
  </header>
  
<main>
  <h1>From RankNet to LambdaRank to LambdaMART: An Overview (2010)</h1>
  <ul class="tags">
    
    <li class="tag">
      <a href="https://ryotaro.dev/tags/%E3%83%A9%E3%83%B3%E3%82%AD%E3%83%B3%E3%82%B0%E5%AD%A6%E7%BF%92/">
        #ランキング学習
      </a>
    </li>
    
  </ul>
  <span class="date">
    
    February 3, 2023
    
  </span>
  <div>
    <p>LambdaMARTは、勾配ブースティング決定木(MART)の訓練に、<a href="https://icml.cc/2015/wp-content/uploads/2015/06/icml_ranking.pdf">RankNet</a>と<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/lambdarank.pdf">LambdaRank</a>を応用したランキング学習である。
RankNetとLambdaRankを以前抄訳で解説した(<a href="/posts/learning_to_rank_using_gradient_descent/">RankNet</a>, <a href="/posts/learning_to_rank_with_nonsmooth_cost_functions/">LambdaRank</a>)。
RankNetは、名前にNetがついているが、RankNetの論文で提案されたものは、ネットワークアーキテクチャではなくランキング学習のための損失関数である。
入力されたベクトルをモデルが実数に写像することができれば、ニューラルネットワークでなくてもよい。
RankNetの学習は、モデルの出力する実数をスコアとみなし、あるクエリに該当する2つの事例のうち、より該当する事例に高いスコアを与えられるようにモデルを訓練する。
各訓練データはランキングの異なる2つの特徴とランキングの高い方を示すラベルであり、2つのスコアの差をシグモイドに与えたときの出力を、一方のサンプルが他方よりもランキングが高い確率とみなす。
そして、交差エントロピーが最小になるようにモデルを訓練する。
LambdaRankは、損失の計算を省き、スコアと損失の勾配で重みを更新することで、RankNetの学習を高速化する。
LambdaMARTは、RankNetに勾配ブースティング決定木を使い、残差の計算にLambdaRankを応用したランキング学習のモデルである。</p>
<p>MARTは、スコアについての損失の勾配を予測する決定木の学習をくりかえす。
\(i\)回目に訓練した決定木を\(f_i(x)\), その重みを\(\alpha_i\)とするとMARTを関数
</p>
$$
F\_N(x) = \sum^N\_{i=1}\alpha\_if\_i(x)
$$<p>
であらわせる。
損失関数を\(C\), 学習データの数を\(m\)、\(i\)番目の特徴を\(x_i\)とおけば、\(N+1\)番目の決定木は、\(x_i, i=1,\dots m\)における微分係数\(\frac{\partial C}{\partial F_N}\)を学習する。
損失とスコアの微小変化の関係
</p>
$$
\delta C\approx\frac{\partial C(F\_N)}{\partial F\_N}\partial F
$$<p>
より、学習率を\(\eta\)として\(\delta F=-\eta \frac{\partial\mathcal{C}}{\partial F_N}\)であれば、\(\delta C&lt;0\)であり、決定木を追加して損失を減らすことを期待できる。</p>
<p>MARTを二値分類のために訓練する場合、\(m\)番目の決定木の\(j\)番目の葉の出力\(\gamma_{jm}\)を求める。
学習データのラベルを\(y_i\in\{\pm 1\}\), \(P_+\equiv P(y=1|x)\), \(P_-\equiv P(y=-1|x)\)とする。
ロジスティック回帰はオッズ比の対数のモデルであることより
</p>
$$
F\_N(x)=\frac{1}{2}\log\left(\frac{P\_+}{P\_-}\right)
$$<p>
または
</p>
$$
\begin{align}
P\_+&=\frac{1}{1+e^{-2\sigma F\_N(x)}}\\\\
P\_-&=1-P\_+=\frac{1}{1+e^{2\sigma F\_N(x)}}
\end{align}
$$<p>
である。損失関数\(L(y,F_N)\)が交差エントロピーであれば
</p>
$$
L(y,F\_N) =\log\left(1+e^{-2y\sigma F\_N}\right)
$$<p>
である。\(m\)番目の決定木の\(j\)番目の葉にあるサンプルの集合を\(R_{jm}\)とすると\(\gamma_{jm}\)は、
</p>
$$
\gamma\_{jm}=\underset{\gamma}{\operatorname{argmin}}\sum\_{x\_i\in R\_{jm}}\log\left(1+e^{-2y\_i\sigma(F\_{m-1}(x\_i)+\gamma)}\right)\equiv \underset{\gamma}{\operatorname{argmin}}g(\gamma)
$$<p>
MARTは、ニュートンラプソン法によって以下の更新式で反復的に\(\gamma\)の近似解を求める。
LambdaMARTは、この更新でLambdaRankを利用する。
</p>
$$
\gamma\_{n+1}=\gamma\_n - \frac{g'(\gamma\_n)}{g''(\gamma\_n)}
$$<p>LamdaRankを導入するために、MARTから離れ、RankNetの話をする。
RankNetは、あるクエリに該当した2つのURL \(U_i, U_j\)があり、そのスコア\(s_i, s_j\)があれば、\(U_i\)が\(U_j\)よりも高いランキングである確率\(P_{ij}\)を
</p>
$$
P\_{ij}\equiv\frac{1}{1+e^{-\sigma(s\_i-s\_j)}}
$$<p>
とする。
RankNetの各学習データは、2つの特徴\(U_i, U_j\)とランキングのより高い方を示すラベルからなる。
ラベルを\(S_{i,j}\in\{0,\pm 1\}\)とし、\(i\)のランキングが\(j\)より高ければ\(1\), 低ければ\(-1\), 同じであれば\(0\)とする。
このとき、\(\bar{P}_{ij}=\frac{1}{2}(1+S_{ij})\)として交差エントロピーを損失\(C\)とすると
</p>
$$
\begin{align}
C&=-\bar{P}\_{ij}\log P\_{ij}-(1-\bar{P}\_{ij})\log(1-P\_{ij})\\\\
C&=\frac{1}{2}(1-S\_{ij})\sigma(s\_i-s\_j) + \log\left(1+e^{-\sigma(s\_i-s\_j)}\right)
\end{align}
$$<p>
である。この\(C\)の微小変化\(\delta C\)を負にするには、
</p>
$$
\delta C=\sum\_k \frac{\partial C}{\partial w\_k}\delta w\_k=\sum\_k \frac{\partial C}{\partial w\_k}\left(-\eta \frac{\partial C}{\partial w\_k}\right)=-\eta \sum\_k\left(\frac{\partial C}{\partial w\_k}\right)^2 < 0
$$<p>
より\(\delta w_k=-\eta\frac{\partial C}{\partial w_k}\)であればよい。</p>
<p>ここで、モデルのあるパラメータを\(w_k\)とし、\(C\)を合成関数とみると
</p>
$$
\begin{align}
\frac{\partial C}{\partial w\_k}
&=\frac{\partial C}{\partial s\_i}\frac{\partial s\_i}{\partial w\_k} + \frac{\partial C}{\partial s\_j}\frac{\partial s\_j}{\partial w\_k}\\\\
&=\sigma \left(\frac{1}{2}(1-S\_{ij})-\frac{1}{1+e^{\sigma(s\_i-s\_j)}} \right)\left(\frac{\partial s\_i}{\partial w\_k}-\frac{\partial s\_j}{\partial w\_k}\right)\\\\
&=\lambda\_{ij}\left(\frac{\partial s\_i}{\partial w\_k}-\frac{\partial s\_j}{\partial w\_k}\right)
\end{align}
$$<p>
となる。ただし
</p>
$$
\lambda\_{ij}\equiv\frac{\partial C(s\_i-s\_j)}{\partial s\_i}=\sigma \left(\frac{1}{2}(1-S\_{ij})-\frac{1}{1+e^{\sigma(s\_i-s\_j)}} \right)
$$<p>
と定義した。
任意の\(i,j\)について\(S_{ij}=1\)となる学習データの集合\(I\)があれば
</p>
$$
\lambda\_i = \sum\_{j:\\{i,j\\}\in I}\lambda\_{ij} - \sum\_{j:\\{j,i\\}\in I}\lambda\_{ij}
$$<p>
とおくとき
</p>
$$
\delta w\_k=-\eta\sum_{\\{i,j\\}\in I}\left(\lambda\_{ij}\frac{\partial s\_i}{\partial w\_k}-\lambda\_{ij}\frac{\partial s\_j}{\partial w\_k}\right)\equiv -\eta \sum\_i\lambda\_i\frac{\partial s\_i}{\partial w\_k}
$$<p>
である。もともとのRankNetは各学習データを処理する度に重みを更新していたが、LambdaRankは\(\lambda_i\)によってURLごとに計算をまとめ、重みの更新頻度を減らし、計算を高速化する。
LamdaRankは、ほかにも、モデルの評価にNDCGを使う場合、\(U_i\)と\(U_j\)を入れ換えたときのNDCGの変化の大きさを\(|\Delta_{\textrm{NDCG}}|\)として
</p>
$$
\lambda\_{ij}=\frac{\partial C(s\_i-s\_j)}{\partial s\_i}=\frac{-\sigma}{1+e^{\sigma(s\_i-s\_j)}}|\Delta\_{\textrm{NDCG}}|
$$<p>
とすると評価が上がることを実験的に示した。</p>
<p>MARTに話をもどして、モデルのスコアについての\(L(y, F_N)\)の勾配は
</p>
$$
\bar{y}\_i=-\left[\frac{\partial L(y\_i, F(x\_i))}{\partial F(x\_i)}\right]\_{F(x)=F\_{m-1}(x)}=\frac{2y\_i\sigma}{1+2^{2y\_i\sigma F\_{m-1}(x)}}
$$<p>
である。
これが\(\lambda_{ij}\)に類似することから、LambdaMARTは\(\bar{y}_i\)の代わりに\(\lambda_i\)を利用する。</p>
<!--
MARTは弱学習器が決定木の勾配ブースティングのモデルで。
\\(m\\)件の\\(d\\)次元の特徴とラベルからなる学習データ\\(\\{x\_{i,j},y\_i\\}, i=1,\dots,m, j=1\dots d\\)があるとする。
学習データを

martから説明していく。
lambda rank.
lambda martの説明
-->
<p>論文の<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf">リンク</a></p>
<h2 id="雑記">雑記</h2>
<p>LambdaMARTはAirbnbでも<a href="https://arxiv.org/abs/1810.09591">使われていた</a>。</p>
  </div>
</main>

  
<ul class="pagination">
  
  <li>
    <a href="/posts/principles_of_transaction_oriented_database_recovery/">
      <i class="fa-solid fa-xl fa-angle-left"></i>
    </a>
  </li>
  
  
  <li>
    <a href="/posts/arc005/">
      <i class="fa-solid fa-xl fa-angle-right"></i>
    </a>
  </li>
  
</ul>


  <footer>
    <small>© Ryotaro Nakamura. All Rights Reserved.</small>
  </footer>
</body>


</html>
