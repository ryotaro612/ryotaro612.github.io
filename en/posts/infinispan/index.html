<!DOCTYPE html>
<html lang="en">

<head>
  
  
  <script>(function (w, d, s, l, i) {
      w[l] = w[l] || []; w[l].push({
        'gtm.start':
          new Date().getTime(), event: 'gtm.js'
      }); var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
          'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-W5TDG76');
  </script>
  
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=300,initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css"
    integrity="sha512-NmLkDIU1C/C88wi324HBc+S2kLhi08PN5GDeUVVVC/BVt/9Izdsc9SVeVfA1UZbY3sHUlDSyRXhCzHfr6hmPPw=="
    crossorigin="anonymous" />
  
  <link rel="stylesheet" href="https://ryotaro.dev/scss/base.min.d5f9c6d3a478082690f838fa06a179ccee4dea5bd3f0cb3f4a357e2803c48d33.css">
  
  <link rel="stylesheet" href="https://ryotaro.dev/scss/base.en.min.fabf7968ffbe5ff626ec9a346f0d38e91d0078974112f713b9d25782380a5073.css">
  

<link rel="stylesheet" href="https://ryotaro.dev/scss/single.min.8ed5cbfb3dc516e9c4459a65252e4e6e8e9026aabfa9eb9f602cf53b30754966.css">

<link rel="stylesheet" href="https://ryotaro.dev/scss/posts/single.min.0008713f3f7556e78c13cb8efde9cf534239cb206c10ba85ce5a76e6ae9ce758.css">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://kit.fontawesome.com/e48a1b5aa5.js" crossorigin="anonymous"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css"
  integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi"
  crossorigin="anonymous"
>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js"
  integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ"
  crossorigin="anonymous">
</script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body);">
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},  
        {left: '$$', right: '$$', display: true},    
        {left: '\\(', right: '\\)', display: false},  
        {left: '$', right: '$', display: false}  
      ],
      throwOnError : false
    });
  });
</script>
  <title>Distributed Caches in Infinispan</title>
</head>

<body>
  
  
  <noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W5TDG76" height="0" width="0"
      style="display:none;visibility:hidden" />
  </noscript>
  
  
  <header class="navigation">
    <h2><a href="https://ryotaro.dev/en/">Blanket</a></h2>
    <nav>
      <ul>
        <li><a href="https://ryotaro.dev/en/about">About</a></li>
        <li><a href="https://ryotaro.dev/en/posts">Posts</a></li>
        <li><a href="https://ryotaro.dev/en/tags">Tags</a></li>
        
        <li><a href="https://ryotaro.dev/posts/infinispan/">ja</a></li>
        
      </ul>
      <ul>
        
        <li>
          <a href="https://github.com/ryotaro612">
            <i class="fab fa-github"></i>
          </a>
        </li>
        
        
        <li>
          <a href="https://www.linkedin.com/in/ryotaro612/">
            <i class="fab fa-linkedin-in"></i>
          </a>
        </li>
        
        
        <li>
          <a href="https://speakerdeck.com/ryotaro612/">
            <i class="fa-brands fa-speaker-deck"></i>
          </a>
        </li>
        
        <li>
          <a href="https://ryotaro.dev/en/%20index.xml">
            <i class="fas fa-rss"></i>
          </a>
        </li>
        
      </ul>
    </nav>
  </header>
  
<main>
  <h1>Distributed Caches in Infinispan</h1>
  <ul class="tags">
    
    <li class="tag">
      <a href="https://ryotaro.dev/en/tags/infinispan/">
        #Infinispan
      </a>
    </li>
    
    <li class="tag">
      <a href="https://ryotaro.dev/en/tags/consistent-hashing/">
        #Consistent Hashing
      </a>
    </li>
    
  </ul>
  <span class="date">
    
    August 23, 2025
    
  </span>
  <div>
    <p><a href="https://infinispan.org/">Infinispan</a> is an open-source in-memory data grid and forms the core of <a href="https://www.redhat.com/en/technologies/jboss-middleware/data-grid">Red Hat Data Grid</a>.
It can also serve as a <a href="https://www.keycloak.org/">cache server</a> for <a href="https://www.keycloak.org/">KeyCloak</a>, which provides single sign-on and identity brokering.</p>
<p>The official documentation describes Infinispan as a <a href="https://infinispan.org/use-cases/">drop-in replacement for Redis or Memcached</a>.
It also implements <a href="https://github.com/jsr107/jsr107spec">JSR107</a>, which allows Java clients to interact with an Infinispan cluster via the JCache API.
For example, a client can use a <a href="https://www.javadoc.io/doc/javax.cache/cache-api/latest/index.html">CacheManager</a> to obtain a <a href="https://www.javadoc.io/doc/javax.cache/cache-api/latest/index.html">Cache</a>—a map-like data structure—and perform updates or lookups.</p>
<p>Although it is possible to run an Infinispan node in the same JVM as the client, the <a href="https://www.keycloak.org/high-availability/concepts-multi-site">KeyCloak documentation</a> recommends running clusters and clients on separate servers.
Keeping them separate makes it easier to scale both independently and improves availability.</p>
<p>Infinispan supports four cache modes: local, replicated, distributed, and invalidation.
When clusters and clients run on different servers, only replicated or distributed caches are suitable.
<a href="https://infinispan.org/docs/stable/titles/configuring/configuring.html#invalidation-caches_clustered-caches">Invalidation caches</a> are not recommended in this case.</p>
<p>A replicated cache stores every entry on all nodes, while a distributed cache stores each entry on a subset of nodes.
Because the number of replication requests grows linearly with the number of nodes, the <a href="https://infinispan.org/docs/stable/titles/configuring/configuring.html#replicated-caches_clustered-caches">documentation</a> recommends distributed caches when you have ten nodes or more.
In short, for both high availability and performance, clusters should run on separate servers and use distributed caches.</p>
<p>Node assignment for cache entries is determined using a consistent hashing algorithm.
More precisely, an implementation of <a href="https://infinispan.org/docs/stable/titles/configuring/configuring.html#key-ownership_clustered-caches">ConsistentHashFactory</a> decides how keys are mapped to nodes.
The original consistent hashing algorithm maps keys and nodes into a unit interval, assigning each key to its successor node.
This balances load and minimizes redistribution.
See this <a href="https://ryotaro.dev/en/posts/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web/">post</a> for details on the original algorithm.</p>
<p>Infinispan’s <code>ConsistentHashFactory</code> extends that idea to support replication and transactions, which the original algorithm does not address.
The group of nodes that stores a given entry is called a <strong>segment</strong>.
The first node in the segment is the <strong>primary owner</strong>, while the others serve as <strong>backups</strong>.
Writes are always directed to the primary owner, which stores the entry and then replicates it to the backups.
Thus, <code>ConsistentHashFactory</code> is responsible not only for distributing entries but also for selecting primary owners and backup nodes.</p>
<p>By default, Infinispan uses <a href="https://infinispan.org/docs/stable/titles/configuring/configuring.html#key-ownership_clustered-caches"><code>SyncConsistentHashFactory</code></a>.
The <a href="https://github.com/infinispan/infinispan/blob/68513c2c84ef5203e7543766f5098fbebde91ddd/core/src/main/java/org/infinispan/distribution/ch/impl/SyncConsistentHashFactory.java#L48">implementation in version 15.2.5-final</a> exposes a <code>create</code> method with the following parameters:</p>
<ul>
<li><code>numOwners</code>: the number of nodes that should hold each entry</li>
<li><code>numSegments</code>: the total number of segments</li>
<li><code>members</code>: the list of cluster nodes</li>
<li><code>capacityFactors</code>: a weight per node that influences how many segments it receives</li>
</ul>
<p>A segment is defined as a list of <code>numOwners</code> nodes, with the primary owner listed first.
<code>SyncConsistentHashFactory</code> creates <code>numSegments</code> such segments.
Each key is hashed and mapped to the segment whose hash is closest, ensuring balanced distribution.
By varying the node composition and order per segment, the algorithm achieves load balancing, primary assignment, and replication.
Segment placement also considers the distance between node hashes, while <code>capacityFactors</code> can be used to skew assignments based on node performance.
Notably, <code>numOwners</code> can be adjusted at runtime, but <code>numSegments</code> is fixed.</p>
<p>The hash space spans all non-negative <code>long</code> values, from \(0\) to \(2^{63}-1\).
Segments are placed at evenly spaced intervals (<code>Long.MAX_VALUE / numSegments</code>), with the first segment starting at <code>Long.MAX_VALUE / (2 * numSegments)</code>.
This allocation is implemented in <a href="https://github.com/infinispan/infinispan/blob/68513c2c84ef5203e7543766f5098fbebde91ddd/core/src/main/java/org/infinispan/distribution/ch/impl/SyncConsistentHashFactory.java#L275"><code>computeSegmentHashes</code></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f38ba8">private</span> <span style="color:#f38ba8">long</span><span style="color:#89dceb;font-weight:bold">[]</span> <span style="color:#89b4fa">computeSegmentHashes</span>(<span style="color:#f38ba8">int</span> numSegments) {
</span></span><span style="display:flex;"><span>   <span style="color:#cba6f7">assert</span> segmentSize <span style="color:#89dceb;font-weight:bold">!=</span> 0;
</span></span><span style="display:flex;"><span>   <span style="color:#f38ba8">long</span><span style="color:#89dceb;font-weight:bold">[]</span> segmentHashes <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#cba6f7">new</span> <span style="color:#f38ba8">long</span><span style="color:#89dceb;font-weight:bold">[</span>numSegments<span style="color:#89dceb;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#f38ba8">long</span> currentSegmentHash <span style="color:#89dceb;font-weight:bold">=</span> segmentSize <span style="color:#89dceb;font-weight:bold">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>   <span style="color:#cba6f7">for</span> (<span style="color:#f38ba8">int</span> s <span style="color:#89dceb;font-weight:bold">=</span> 0; s <span style="color:#89dceb;font-weight:bold">&lt;</span> numSegments; s<span style="color:#89dceb;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>      segmentHashes<span style="color:#89dceb;font-weight:bold">[</span>s<span style="color:#89dceb;font-weight:bold">]</span> <span style="color:#89dceb;font-weight:bold">=</span> currentSegmentHash;
</span></span><span style="display:flex;"><span>      currentSegmentHash <span style="color:#89dceb;font-weight:bold">+=</span> segmentSize;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#cba6f7">return</span> segmentHashes;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Keys are hashed using <a href="https://github.com/infinispan/infinispan/blob/68513c2c84ef5203e7543766f5098fbebde91ddd/commons/all/src/main/java/org/infinispan/commons/hash/MurmurHash3.java?utm_source=chatgpt.com#L30">MurmurHash3</a>.
The <a href="https://github.com/infinispan/infinispan/blob/68513c2c84ef5203e7543766f5098fbebde91ddd/core/src/main/java/org/infinispan/distribution/ch/impl/HashFunctionPartitioner.java?utm_source=chatgpt.com#L78">getSegmentForHash</a> method maps the MurmurHash3 result to a segment by dividing the lower 64 bits by the segment size:</p>
<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f38ba8">public</span> <span style="color:#f38ba8">int</span> <span style="color:#89b4fa">getSegmentForHash</span>(<span style="color:#f38ba8">int</span> hash) {
</span></span><span style="display:flex;"><span>   <span style="color:#6c7086;font-style:italic">// Ensure the result is always positive</span>
</span></span><span style="display:flex;"><span>   <span style="color:#cba6f7">return</span> (hash <span style="color:#89dceb;font-weight:bold">&amp;</span> Integer.<span style="color:#89b4fa">MAX_VALUE</span>) <span style="color:#89dceb;font-weight:bold">/</span> segmentSize;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nodes are also hashed with MurmurHash3, but through the use of virtual nodes.
Each node is assigned \(\lceil \log_2(\text{numSegments}-1) \rceil\) virtual nodes.
The \(i\)-th virtual node’s hash is computed from the node’s UUID with \(i\) as the seed.</p>
<p>Primary owners are assigned first, followed by backups.
The distance between a segment and a node is defined as the scaled distance between the segment’s hash and the nearest virtual node hash, adjusted by the node’s capacity relative to the minimum capacity.
Hashes are treated as circular, so the maximum and minimum values are neighbors.
Backups are then selected by inserting all nodes into a priority queue, ordered by scaled distance, and dequeuing \(\texttt{numOwners} - 1\) of them.</p>
  </div>
</main>

  
<ul class="pagination">
  
  <li>
    <a href="/en/posts/amazon.com-recommendations-item-to-item-collaborative-filtering/">
      <i class="fa-solid fa-xl fa-angle-left"></i>
    </a>
  </li>
  
  
  <li>
    <a href="/en/posts/multi-probe-consistent-hashing/">
      <i class="fa-solid fa-xl fa-angle-right"></i>
    </a>
  </li>
  
</ul>


  <footer>
    <small>© Ryotaro Nakamura. All Rights Reserved.</small>
  </footer>
</body>


</html>
