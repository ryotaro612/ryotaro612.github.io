<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分散システム on Blanket</title>
    <link>https://nryotaro.dev/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/</link>
    <description>Recent content in 分散システム on Blanket</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 22 Apr 2023 21:35:08 -0400</lastBuildDate><atom:link href="https://nryotaro.dev/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Virtual Time and Global States of Distributed Systems(1988)</title>
      <link>https://nryotaro.dev/posts/virtual_time_and_global_states_of_distributed_systems/</link>
      <pubDate>Sat, 22 Apr 2023 21:35:08 -0400</pubDate>
      
      <guid>https://nryotaro.dev/posts/virtual_time_and_global_states_of_distributed_systems/</guid>
      <description>&lt;p&gt;分散システムのプロセス間で時刻が常に同期しているとは限らない。
プロセスの時刻から判断すると、プロセスでは、ほかのプロセスのイベントと比べてどちらが先に起きたか分からないイベントが起きえる。
&lt;a href=&#34;https://lamport.azurewebsites.net/pubs/time-clocks.pdf&#34;&gt;Lamport&lt;/a&gt;は、各プロセスに単調増加する論理的な時刻をもたせ、メッセージとともに時刻をプロセス間で交換することで、イベントの依存関係と矛盾せずにイベントを全順序に並べる手法を提案した。
先行するイベントは、必ず後続のイベントよりも小さい時刻をもつ。
しかし、逆は必ずしも成り立たない。
先行する場合もあれば、前後関係がないこともある。
&lt;a href=&#34;http://www.vs.inf.ethz.ch/publ/papers/VirtTimeGlobStates.pdf&#34;&gt;Virtual Time and Global States of Distributed Systems&lt;/a&gt;は、各プロセスの時刻を、プロセス数とおなじ数の長さの配列で表現する。
これにより、時刻の前後関係が定義されていることがイベント間に前後関係があることの必要十分条件であることを可能にした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Proving the Correctness of Multiprocess Programs (1977)</title>
      <link>https://nryotaro.dev/posts/proving_correctness_of_multiprocess_programs/</link>
      <pubDate>Sat, 25 Mar 2023 12:34:08 -0400</pubDate>
      
      <guid>https://nryotaro.dev/posts/proving_correctness_of_multiprocess_programs/</guid>
      <description>&lt;p&gt;マルチプロセスプログラムの正しさを証明するための公理を提案する。
正しさの条件は、プログラムが安全性と活性を満たすことである。
安全はプログラムが特定の状態になりえないことを、活性はプログラムが特定の状態に必ず到達することを意味する。
たとえば、キューにメッセージを配信するproducerとキューから取り出すconsumerがあるとする。
このとき、容量以上のメッセージがキューに蓄積しない性質が安全性に、キューが満杯時にconsumerがメッセージを消費する性質が活性になりえる。
プログラム、安全性、活性を形式化し、安全性と活性を証明することで、プログラムの正しさを示す。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Your Coffee Shop Doesn&#39;t Use Two-Phase Commit(2005)</title>
      <link>https://nryotaro.dev/posts/your_coffee_shop_doesnt_use_two_phase_commit/</link>
      <pubDate>Sun, 12 Mar 2023 16:17:35 -0400</pubDate>
      
      <guid>https://nryotaro.dev/posts/your_coffee_shop_doesnt_use_two_phase_commit/</guid>
      <description>&lt;p&gt;非同期処理を、スターバックスの注文からコーヒーの提供までの流れにたとえたアネクドートである。
注文をうけたレジの店員は、どの客の注文か分かる目印をコーヒーカップに書き、カップをエスプレッソマシンの上にならべる。
客はバリスタのいるカウンターに移動し、レジの店員は次の顧客の注文をうけつける。
バリスタは、ならべられたカップをとり、コーヒーを注ぎ、客に提供する。&lt;/p&gt;
&lt;p&gt;レジの店員とバリスタは非同期にはたらいている。
バリスタのコーヒーの提供が滞っても、レジの店員は注文をうけることができる。
カップの列が長くなれば、バリスタの人数を増やせば、レジの店員に影響することなく、より速くコーヒーを提供できる。
それはキューで通信するプロデューサーとコンシューマーのようである。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Brewer&#39;s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web(2002)</title>
      <link>https://nryotaro.dev/posts/brewers_conjecture_and_the_feasibility_of_consistent_available_partition_tolerant_web/</link>
      <pubDate>Tue, 17 Jan 2023 11:42:12 -0500</pubDate>
      
      <guid>https://nryotaro.dev/posts/brewers_conjecture_and_the_feasibility_of_consistent_available_partition_tolerant_web/</guid>
      <description>&lt;p&gt;分散システムは一貫性、可用性、分断耐性を同時に満たすことができない。
この予想は、2000年のPODCでBrewerが発表したCAP定理として知られている。
しかし、Brewerの&lt;a href=&#34;https://sites.cs.ucsb.edu/~rich/class/cs293-cloud/papers/Brewer_podc_keynote_2000.pdf&#34;&gt;講演&lt;/a&gt;では厳密な定義や証明はない。
そこで、それを補うために、ある2つの計算モデルでCAPが成立することを証明する。
計算モデルは、asynchronous network modelとpartially synchhronous modelである。
asynchronouse network modelでは、モデルのノードは、クロックをもたず、受信したメッセージとノード内の計算のみで出力を決定する。
partially synchronous modelでは、各ノードは、一定間隔で単調増加するクロックをもち、処理をタイムアウトしたり、スケジューリングしたりできる。
ただし、ノード間でクロックが同期されているとは限らない。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Epidemic Algorithm for Replicated Database Maintenance(1987)</title>
      <link>https://nryotaro.dev/posts/epidemic_algorithms_for_replicated_database_maintenance/</link>
      <pubDate>Mon, 19 Dec 2022 11:07:49 -0500</pubDate>
      
      <guid>https://nryotaro.dev/posts/epidemic_algorithms_for_replicated_database_maintenance/</guid>
      <description>&lt;p&gt;Epidemic Algorithmは、データベース間の差分を解消するために、データベースがランダムに選んだ別のデータベースと同期する手法である。
Epidemicを邦訳すると伝染性である。
ここではデータベースにはマスタースレーブの区別はなく、任意のサーバーがレコードの変更リクエストを受理できる。
Epidemic Algorithmには、定期的にデーターベース全体を同期する手法と、変更を受理したときに当該の変更のみを別のデータベースに伝搬させる手法の2つがある。
前者は、データベース全体を同期するので変更のとりこぼしがいずれは解消されるが、同期に時間がかかる。
後者は、時間はかからないが、伝搬を終えるまでに同期できなかった変更があれば、その齟齬が残りつづける。
データベースがある時点で最新の変更をもたない確率を仮定し、その確率で次の同期で変更を取得できる確率を表し、手法間の同期する収束の速さを比較した。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>An Improved Data Stream Summary: The Count-Min Sketch and its Applications(2005)</title>
      <link>https://nryotaro.dev/posts/an_improved_data_stream_summary_the_count_min_sketch_and_its_application/</link>
      <pubDate>Wed, 07 Dec 2022 12:29:36 -0500</pubDate>
      
      <guid>https://nryotaro.dev/posts/an_improved_data_stream_summary_the_count_min_sketch_and_its_application/</guid>
      <description>&lt;p&gt;Count-Min Sketch(CM Sketch)は、単位時間ごとに1要素ずつ更新される\(n\)次元のベクトルの要素を\(n\)の劣線形の計算量で集計できるデータ構造である。
空間の大きさはパラメタで指定する誤差大きさと誤差の生じる確率に依存する。
誤差と確率のパラメタを\(\epsilon\)と\(\delta\)とすると、CM sketchは\(\lceil{\ln \frac{1}{\delta}\rceil}\times \lceil\frac{e}{\epsilon}\rceil\)の二次元行列である。
\(\ln\)の底は\(e\)である。
要素の値、ベクトルの内積、ある範囲の要素の和を劣線形の計算量で求めることができる。
また、これらと二分探索を応用すれば、指定した値よりも大きい要素のみからなる範囲や分位数も計算できる。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MillWheel: Fault-Tolerant Stream Processing at Internet Scale(2013)</title>
      <link>https://nryotaro.dev/posts/millwheel_fault_tolerant_stream_processing_at_internet_scale/</link>
      <pubDate>Wed, 23 Nov 2022 11:44:08 -0500</pubDate>
      
      <guid>https://nryotaro.dev/posts/millwheel_fault_tolerant_stream_processing_at_internet_scale/</guid>
      <description>&lt;p&gt;MillWheelはGoogleで開発されたストリーミング処理のフレームワークである。
開発者が羃等な処理をノードとする有向グラフを実装すれば、MillWheelがデータをノードに正確に一回だけ配信する。
ただし、転送が遅延しているデータは破棄される。
データは、キー、値、論理的な時刻の3組からなるレコードを単位として、ノードからノードに出力される。
向き先のノードは、レコードからキーへの関数を、根のノードから出力されるレコードに適用し、期待するキーに対応するレコードをノードに集約する。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
